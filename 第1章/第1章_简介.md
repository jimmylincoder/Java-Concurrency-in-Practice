#第1章 简介
###1.1并发简史
早期计算机（不包含操作系统，只有运行一个程序，资源利用率低）---> 
出现操作系统（可运行多个程序，多进程之间有各自的资源，但不同进程之间要通过通信机制来交换数据，例:套接字、信号处理器、共享内存、信号量以及文件）--> 出现线程（共享进程范围内的资源）

计算机加入操作系统多进程主要原因：

a.资源利用率

b.公平性

c.便利性

###1.2线程的优势
####发挥多处理器的强大能力
####建模的简单性
####异步事件的简化处理
####响应更灵敏的用户界面

###1.3线程带来的风险
####安全性问题
以下这个类在单线程环境中能正确的工作，但在多线程环境中则不能，会出现竞态条件

```
@NotThreadSafe
public class UnsafeSequence
{
	private int value;
	
	//返回一个唯一的数值
	public int getNext()
	{
		return value++;
	}
}

```
如果执行时机不对，那么两个线程在调用getNext时会得到相同的值，得到错误的结果。

value++看上去是单个操作，但事实上它包含三个独立的操作:读取value,将value+1，并将计算结果写入value。由于运行时可能将多个线程之间的操作交替执行，因些这两个线程可能同时执行操作，从而使它们得到相同的值，并都将这个值加1，结果在不同线程的调用中返回了相同的数值

我们可以使用Java提供的同步机制来协同这种方问

线程安全的数值序列生成器

```
@ThreadSafe
public class Sequence
{
	@GuardeBy("this")  private int value;
	
	public synchronized int getNext()
	{
		return Value++;
	}
}

```
####活跃性问题
安全性问题含义:永远不会发生糟糕事情，而活跃性则关注于另一个目标，即某件正确的事件最终会发生。当某个操作无法继续执行下去时，就会发生活跃性问题。造成影响就是:无意中造成的无限循环，从而使循环之后的代码无法得到执行。

####性能问题
性能问题就是希望正确的事情尽快发生。性能问题包括多个方面，例如服务时间过长，响应不灵敏，吞吐率过低，资源消耗过高，或者可伸缩性较低等。

###线程无处不在
每个Java应用程序都会使用线程。当JVM启动时，它将为JVM的内部任务（例如，垃圾收集、终结操作等）创建后台线程，并创建一个主线程来运行main方法。




